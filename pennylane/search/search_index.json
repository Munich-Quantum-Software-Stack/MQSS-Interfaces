{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MQP Pennylane Adapter Documentation","text":"<p>This is the documentation for the MQSS Pennylane Adapter.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with the MQSS Pennylane Adapter, refer to the Getting Started guide.</p>"},{"location":"#development-guide","title":"Development Guide","text":"<p>For information on setting up the development environment and contributing to the project, refer to the Development Guide.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>Detailed API documentation for the MQSS Pennylane Adapter:</p> <ul> <li>MQSSPennylaneDevice: Custom Pennylane device for MQSS resources.</li> <li>MQSSPennylaneBackend: Interfaces with the MQSS backends.</li> <li>MQPJob: Manages job execution and results retrieval.</li> </ul>"},{"location":"#change-log","title":"Change Log","text":"<p>See the CHANGELOG for details on changes in each version.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#version-101","title":"Version 1.0.1","text":"<ul> <li>Implements Hamiltonian expectation value calculation support</li> </ul>"},{"location":"CHANGELOG/#version-100","title":"Version 1.0.0","text":"<ul> <li>Implements Pennylane circuit execution</li> </ul>"},{"location":"contact/","title":"Contact","text":"<p>If you encounter any bugs or issues, please let us know by opening a new issue.</p>"},{"location":"api/MQPJob/","title":"MQPJob","text":"<p>               Bases: <code>JobV1</code></p> <p>MQPJob Class</p>"},{"location":"api/MQPJob/#mqss.pennylane_adapter.job.MQPJob.result","title":"result","text":"<pre><code>result()\n</code></pre> <p>Fetches the results from the MQSS Backend and returns it to the user. The returned object includes: result_dict = {     \"job_id\": self._job_id,     \"success\": True|False,     \"results\": [         {             \"shots\": sum(_counts.values()),             \"success\": True|False,             \"data\": {                 \"counts\": Counts(_counts),             },         }         for _counts in res_counts     ],     \"timestamps\": {         \"submitted\": res.timestamp_submitted,         \"scheduled\": res.timestamp_scheduled,         \"completed\": res.timestamp_completed,     }, }</p> <p>Returns:</p> Name Type Description <code>result_dict</code> <p>dict</p>"},{"location":"api/MQPJob/#mqss.pennylane_adapter.job.MQPJob.status","title":"status","text":"<pre><code>status()\n</code></pre> <p>Returns the job status</p> <p>Raises:</p> Type Description <code>RuntimeWarning</code> <p>Unknown job status</p> <p>Returns:</p> Name Type Description <code>status</code> <p>QiskitJobStatus</p>"},{"location":"api/MQSSPennylaneBackend/","title":"MQSSPennylaneBackend","text":"<p>               Bases: <code>BackendV2</code></p> <p>MQP Pennylane Backend class responsible for handling requests and responses from the MQSS Backend.</p>"},{"location":"api/MQSSPennylaneBackend/#mqss.pennylane_adapter.backend.MQSSPennylaneBackend.coupling_map","title":"coupling_map  <code>property</code>","text":"<pre><code>coupling_map: CouplingMap\n</code></pre> <p>Returns the coupling map of the selected backend</p> <p>Returns:</p> Name Type Description <code>CouplingMap</code> <code>CouplingMap</code> <p>CouplingMap</p>"},{"location":"api/MQSSPennylaneBackend/#mqss.pennylane_adapter.backend.MQSSPennylaneBackend.run","title":"run","text":"<pre><code>run(run_input: Union[QuantumCircuit, List[QuantumCircuit]], shots: int = 1024, no_modify: bool = False, **options) -&gt; MQPJob\n</code></pre> <p>Sends the quantum circuit(s) to the selected backend.</p> <p>Parameters:</p> Name Type Description Default <code>run_input</code> <code>Union[QuantumCircuit, List[QuantumCircuit]]</code> <p>Pennylane circuit</p> required <code>shots</code> <code>int</code> <p>Number of shots. Defaults to 1024.</p> <code>1024</code> <code>no_modify</code> <code>bool</code> <p>Flag to bypass MQSS transpilation. no_modify=True means the transpilation will be bypassed if possible. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>MQPJob</code> <code>MQPJob</code> <p>Returns the MQPJob object</p>"},{"location":"api/MQSSPennylaneDevice/","title":"MQSSPennylaneDevice","text":"<p>               Bases: <code>Device</code></p> <p>Implements a Custom Pennylane Device that uses MQSS as a backend.</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice--attributes","title":"Attributes","text":"<p>TOKEN : str     Munich Quantum Portal (MQP) Token BACKENDS : str     Munich Quantum Portal (MQP) Backend Methods</p> <p>init(self):     Constructor execute(self, circuits, execution_config, shots):     Sends the Pennylane circuit to the specified MQSS backend.</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.__init__","title":"__init__","text":"<pre><code>__init__(token: str, backends: str, wires=None, shots=None, seed=None, supports_derivatives=False)\n</code></pre> <p>Construct an MQSSPennylaneDevice Object</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Munich Quantum Portal (MQP) token</p> required <code>backends</code> <code>str</code> <p>MQP backend</p> required <code>wires</code> <code>int</code> <p>Number of wires in the circuit Defaults to None.</p> <code>None</code> <code>shots</code> <code>int</code> <p>Number of shots, for expectation values leave it as None. Defaults to None.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Defaults to None.</p> <code>None</code> <code>supports_derivatives</code> <code>bool</code> <p>Boolean flag for autograd support. Defaults to False.</p> <code>False</code>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.append_measurement_gates","title":"append_measurement_gates","text":"<pre><code>append_measurement_gates(circuits: QuantumScriptOrBatch, obs: ops, is_hamiltonian: bool) -&gt; QuantumScriptOrBatch\n</code></pre> <p>Append gates for basis change for measurements in non-Z basis.</p> <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>QuantumScriptOrBatch</code> <p>Pennylane circuit</p> required <code>obs</code> <code>ops</code> <p>The measured observable</p> required <code>is_hamiltonian</code> <code>bool</code> <p>Indicates if there is a hamiltonian expectation value calculation</p> required"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.calculate_measurement_type","title":"calculate_measurement_type","text":"<pre><code>calculate_measurement_type(counts: TensorLike, circuits: QuantumScriptOrBatch, shots: int, is_hamiltonian: bool) -&gt; Union[list[TensorLike], list[float]]\n</code></pre> <p>Given a measurement type (e.g. probs, exp. val.), return the measurement result.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>list</code> <p>List of sampled measurements</p> required <code>circuits</code> <code>Qnode</code> <p>Pennylane circuit</p> required <code>shots</code> <code>int</code> <p>Number of shots</p> required <code>is_hamiltonian</code> <code>bool</code> <p>Indicates if there is a hamiltonian expectation value calculation</p> required"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.create_batch_circuits_for_hamiltonians","title":"create_batch_circuits_for_hamiltonians","text":"<pre><code>create_batch_circuits_for_hamiltonians(tape: QuantumScriptOrBatch, is_hamiltonian: bool) -&gt; list[QuantumScriptOrBatch]\n</code></pre> <p>Creates a batched job where there is a Hamiltonian expectation value calculation as measurement</p> <p>Parameters:</p> Name Type Description Default <code>tape</code> <code>QuantumScriptOrBatch</code> <p>Original quantum circuit</p> required <code>is_hamiltonian</code> <code>bool</code> <p>Indicates if there is a hamiltonian expectation value calculation</p> required <p>Returns:</p> Type Description <code>list[QuantumScriptOrBatch]</code> <p>list[QuantumScriptOrBatch]: Batch of circuits for each term in the Hamiltonian</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.execute","title":"execute","text":"<pre><code>execute(circuits: QuantumScriptOrBatch, execution_config: DefaultExecutionConfig, shots=1024) -&gt; TensorLike\n</code></pre> <p>Sends the Pennylane circuit to the specified MQSS backend.</p> <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>QuantumScriptOrBatch</code> <p>Pennylane circuit</p> required <code>execution_config</code> <code>DefaultExecutionConfig</code> <p>Additional config for the circuit if necessary</p> required <code>shots</code> <code>int</code> <p>Number of shots. Defaults to 1024.</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>TensorLike</code> <code>TensorLike</code> <p>Measurement results</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.fetch_counts","title":"fetch_counts","text":"<pre><code>fetch_counts(result: Union[Result, ResultBatch], shots: int) -&gt; list[Result]\n</code></pre> <p>Given a dictionary representing the measurements, return the probability distribution as an array</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Result</code> <p>Results of the quantum job</p> required <code>shots</code> <code>int</code> <p>Number of shots</p> required <p>Returns:</p> Name Type Description <code>probs</code> <code>ndarray</code> <p>The probability distribution of the measurements</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.get_expectation_value","title":"get_expectation_value","text":"<pre><code>get_expectation_value(count: list[float], measured_qubits: list[int], num_qubits: int, shots: int)\n</code></pre> <p>Calculate the expectation value from the counts</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>list[float]</code> <p>List of sampled measurements</p> required <code>measured_qubits</code> <code>list[int]</code> <p>The qubits involved in measurement process</p> required <code>num_qubits</code> <code>int</code> <p>Number of circuits of the given circuit</p> required <code>shots</code> <code>int</code> <p>Number of shots</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised in case of the number of wires missing</p>"},{"location":"api/MQSSPennylaneDevice/#mqss.pennylane_adapter.device.MQSSPennylaneDevice.validate_tape_operations","title":"validate_tape_operations","text":"<pre><code>validate_tape_operations(tape: QuantumScriptOrBatch)\n</code></pre> <p>Validate if the operations in the tape are all supported</p> <p>Parameters:</p> Name Type Description Default <code>tape</code> <code>QuantumScriptOrBatch</code> <p>Pennylane circuit</p> required"},{"location":"user_guide/development_guide/","title":"Development Guide","text":""},{"location":"user_guide/development_guide/#project-overview","title":"Project Overview","text":"<p>This project provides a Pennylane Adapter for MQSS, allowing users to access MQSS backends through Pennylane. The main components of the project are:</p> <ul> <li><code>provider.py</code>: Contains the <code>MQSSPennylaneDevice</code> class, which serves as the main entry point for defining MQSS devices in Pennylane.</li> <li><code>backend.py</code>: Contains the <code>MQSSPennylaneBackend</code> class, which interfaces with the MQSS backends.</li> <li><code>job.py</code>: Contains the <code>MQPJob</code> class, which handles job cancellation, status checking, and result retrieval.</li> </ul>"},{"location":"user_guide/development_guide/#prerequisites","title":"Prerequisites","text":"<p>Before you start developing, ensure you have the following installed:</p> <ul> <li>Python 3.8 to 3.11</li> <li><code>uv</code> package manager for python</li> </ul>"},{"location":"user_guide/development_guide/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<p>Clone the repository:</p> <pre><code>git clone https://github.com/Munich-Quantum-Software-Stack/MQP-Qiskit-Provider.git\ncd MQP-Qiskit-Provider\n</code></pre> <p>Create a virtual environment and install the dependencies:</p> <pre><code>pdm install\n</code></pre>"},{"location":"user_guide/development_guide/#running-tests","title":"Running Tests","text":"<p>To run the tests, use <code>pytest</code>:</p> <pre><code>pdm run pytest\n</code></pre>"},{"location":"user_guide/development_guide/#publishing-documentation-on-github-pages","title":"Publishing Documentation on GitHub Pages","text":"<p>To publish the documentation on GitHub Pages, follow these steps:</p> <p>Install MkDocs and the Material theme:</p> <pre><code>pdm install -G docs\n</code></pre> <p>Build the documentation:</p> <pre><code>pdm run mkdocs build\n</code></pre> <p>View documentation locally</p> <p>Run the following and browse the documentation locally at: http://localhost:8000</p> <pre><code>pdm run mkdocs serve\n</code></pre> <p>Deploy the documentation to GitHub Pages:</p> <pre><code>pdm run mkdocs gh-deploy --remote-name git@github.com:Munich-Quantum-Software-Stack/MQP-Qiskit-Provider-Documentation.git --remote-branch gh-pages\n</code></pre> <p>This will create a new branch named <code>gh-pages</code> in your repository and deploy the documentation to GitHub Pages.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>This repository implements a custom PennyLane backend called MQSSPennylaneDevice, which is able to send quantum jobs to LRZ's infrastructure using the PennyLane frontend.  The users would be able to use various PennyLane functions (executing circuits, different measurement types. For future releases: circuit optimization and Quantum Machine Learning) while running their jobs on LRZ's Quantum Hardware.</p>"},{"location":"user_guide/getting_started/#installation","title":"\ud83d\udee0\ufe0f Installation","text":"<p>To install the package, simply run  <pre><code>pip install mqss-pennylane-adapter\n</code></pre></p>"},{"location":"user_guide/getting_started/#usage","title":"\ud83d\ude80 Usage","text":"<p>MQSS PennyLane Provider has support for most of the native PennyLane features. For instance, you can define a quantum circuit using PennyLane quantum gates, and decorate the method with the MQSSPennylaneDevice object. Parametric gates can also be used.  <pre><code>import pennylane as qml\nfrom pennylane import numpy as np\nfrom mqss.pennylane_adapter.device import MQSSPennylaneDevice\n\ndev = MQSSPennylaneDevice(wires=2, token=MQSS_TOKEN, backends=MQSS_BACKENDS)\n\n@qml.qnode(dev)\ndef quantum_function_expval(x, y):\n    \"\"\"\n    The function `quantum_function_expval` applies quantum operations RZ, CNOT, and RY to qubits and returns\n    the expectation value of PauliZ on the second qubit.\n\n    :param x: The parameter `x` in the `quantum_function_expval` represents the angle for the rotation gate\n    `RZ` applied on the qubit at wire 0\n    :param y: The parameter `y` in the `quantum_function_expval` function is used as the angle parameter for\n    the rotation gate `RY(y, wires=1)`. This gate applies a rotation around the y-axis of the Bloch\n    sphere by an angle `y` to the qubit on wire\n    :return: The function `quantum_function_expval` returns the expected value of the given operator\n    \"\"\"\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\nparams = [np.pi / 3, np.pi / 17]\nresult = quantum_function_expval(*params)\n</code></pre> Furthermore, you can define a Hamiltonian object within PennyLane, and calculate the expectation value with respect to that Hamiltonian. For these cases, Pennylane Provider simply creates a batch job for each term in the Hamiltonian, to calculate the expectation value.</p> <pre><code>import pennylane as qml\nfrom pennylane import numpy as np\nfrom mqss.pennylane_adapter.device import MQSSPennylaneDevice\ndev_hamiltonian = MQSSPennylaneDevice(wires=2, token='&lt;MQSS_TOKEN&gt;', backends='&lt;MQSS_BACKENDS&gt;')\n\ndef arbitrary_quantum_circuit(x: float, y: float) -&gt; None:\n    \"\"\"\n    Defines an arbitrary mock quantum circuit for testing purposes, without a measurement operation\n\n    :param x: The parameter `x` in the `quantum_function_expval` represents the angle for the rotation gate\n    `RZ` applied on the qubit at wire 0\n    :param y: The parameter `y` in the `quantum_function_expval` function is used as the angle parameter for\n    the rotation gate `RY(y, wires=1)`. This gate applies a rotation around the y-axis of the Bloch\n    sphere by an angle `y` to the qubit on wire\n    \"\"\"\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=1)\n\n@qml.qnode(dev_hamiltonian)\ndef quantum_function_hamiltonian_expval(\n    x: float, y: float, H: qml.Hamiltonian\n) -&gt; float:\n    \"\"\"\n    The function `quantum_function_expval` applies quantum operations RZ, CNOT, and RY to qubits and returns\n    the expectation value of PauliZ on the second qubit.\n\n    :param x: The parameter `x` in the `quantum_function_expval` represents the angle for the rotation gate\n    `RZ` applied on the qubit at wire 0\n    :param y: The parameter `y` in the `quantum_function_expval` function is used as the angle parameter for\n    the rotation gate `RY(y, wires=1)`. This gate applies a rotation around the y-axis of the Bloch\n    sphere by an angle `y` to the qubit on wire\n    :return: The function `quantum_function_expval` returns the expected value of a given operator\n    :H: Pennylane Hamiltonian object\n    \"\"\"\n    arbitrary_quantum_circuit(x, y)\n\n    return qml.expval(H)\n\nJ = 0.5  # Interaction strength\nh = 0.2  # Transverse field strength\ncoeffs = [-J, -h, -h]  # TFIM with 2 sites\nobs = [\n    qml.PauliZ(0) @ qml.PauliZ(1),  # Ising interaction between sites 0 and 1\n    qml.PauliX(0),\n    qml.PauliX(1),\n]\n\nhamiltonian = qml.Hamiltonian(coeffs, obs)\nresult = quantum_function_hamiltonian_expval(*params, hamiltonian)\n</code></pre> <p>If you are just interested in accessing the counts, you can also use</p> <pre><code>import pennylane as qml\nfrom pennylane import numpy as np\nfrom mqss.pennylane_adapter.device import MQSSPennylaneDevice\nn_wires = 5\ndev_hamiltonian = MQSSPennylaneDevice(wires=n_wires, token='&lt;MQSS_TOKEN&gt;', backends='&lt;MQSS_BACKENDS&gt;')\n@qml.qnode(dev)\ndef circuit(\n    x: float, y: float\n) -&gt; float:\n\n    arbitrary_quantum_circuit(x, y)\n\n    return qml.probs(range=(0, n_wires))\n</code></pre>"},{"location":"user_guide/getting_started/#upcoming-features","title":"\ud83d\udee0\ufe0f Upcoming Features","text":"<ul> <li>Autograd support with parameter-shift</li> <li>Grouping of commuting terms in the Hamiltonians to reduce the number of circuits in the batch</li> </ul>"},{"location":"user_guide/getting_started/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Feel free to open issues or submit pull requests to improve this project!</p>"}]}